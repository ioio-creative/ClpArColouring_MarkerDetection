/*
This project uses the idea from Ch2 of the book
"Mastering OpenCV with Practical Computer Vision Projects".
The technique is used in the book for Marker Based AR Application.

I use the technique of detecting markers to check if the 4 corners of
an A4 paper are all present in an image.
This is achieved by placing the 4 different markers in the 4 corners of the paper
respectively, then take a picture of the A4 paper.
These marker patterns can be generated by the GenerateBitmapFrom2dArray project.
C:\Users\IOIO\Documents\Projects\C#.NET\GenerateBitmapFrom2dArray

The markers pattern are defined in main.cpp as refMarkersToTest.
In the 4 5x5 bitmaps, 1 represents white and 0 represents black cell in the
square marker.

Different integer codes will be returned from the main function depending on
which corner of the A4 paper (equivalently which marker pattern)
is missing from the image.
If all 4 corners are present, 0 will be returned.

by Christopher Wong, 2017-08-10

Also, based on the detected coordinates of the markers in the image and 4 pairs
of predefined coordinates, named targetWarpedImgMarkerPoints,
a perspective transform is performed on the input image so that the A4 paper part
of the input image will be warped into a rectangular image.

by Christopher Wong, 2017-08-14

*/


// File includes:
#include "MarkerDetector.hpp"
#include "DebugHelpers.hpp"

// Standard includes:
#include <iostream>
#include <opencv2/opencv.hpp>

void processSingleImage(const cv::Mat& image, const int refMarkers[4][5][5],
	bool isMarkersPresent[4], bool& isControlMarkerPresentAndNotDisplaced,
	std::string outputImageName);
bool processFrame(const cv::Mat& cameraFrame, MarkerDetector& markerDetector,
	bool isMarkersPresent[4], bool& isControlMarkerPresentAndNotDisplaced,
	std::string outputImageName);

// TODO:
// This is where the marker patterns are defined
// https://stackoverflow.com/questions/42699360/initialize-const-3d-array-member-variable/42699720
const int refMarkersToTest[4][5][5] =
{
	// id = 638
	{
		{ 1,0,0,0,0 },
		{ 1,0,1,1,1 },
		{ 0,1,0,0,1 },  // why is this one here?
		{ 0,1,1,1,0 },
		{ 0,1,1,1,0 }   // duplicated to make up 5 rows
	},

	// id = 193
	{
		{ 1, 0, 1, 1, 0 },
		{ 0, 1, 0, 0, 1 },
		{ 1, 1, 1, 0, 1 },
		{ 0, 1, 0, 0, 0 },
		{ 1, 1, 1, 1, 1 }
	},

	// id = 390
	{
		{ 0, 1, 1, 0, 1 },
		{ 1, 0, 0, 1, 0 },
		{ 1, 0, 1, 0, 1 },
		{ 0, 1, 0, 0, 1 },
		{ 1, 0, 1, 1, 0 }
	},

	// id = 3
	{
		{ 1, 0, 1, 1, 0 },
		{ 0, 0, 0, 0, 1 },
		{ 1, 0, 1, 0, 0 },
		{ 0, 0, 0, 0, 1 },
		{ 0, 1, 1, 1, 0 }
	},
};

// served as control to detect if the coloured paper is "curved"
const int controlMarkerToTest[5][5]
{
	{ 0, 0, 0, 1, 1 },
	{ 1, 1, 0, 1, 0 },
	{ 0, 1, 1, 1, 1 },
	{ 1, 1, 0, 0, 0 },
	{ 0, 0, 0, 1, 0 }
};


// TODO: hard-coded here
// targetWarpedImgWidth, targetWarpedImgHeight, targetWarpedImgMarkerPoints
// are the parameters required for perspectively warping 

// targetWarpedImgWidth, targetWarpedImgHeight are the width and height
// of the warped result
// used in cv::warpPerspective
const int targetWarpedImgWidth = 2481;
const int targetWarpedImgHeight = 3508;

// targetWarpedImgMarkerPoints are the coordinates of the markers in the
// reference result
// used in cv::getPerspectiveTransform
// targetWarpedImgMarkerPoints have to be in fixed order:
// top-left, top-right, bottom-left, bottom-right
const cv::Point2f targetWarpedImgMarkerPoints[4] =
{						
	cv::Point2f(212.054626, 198.778656),
	cv::Point2f(2269.94556, 198.778961),
	cv::Point2f(211.999084, 2776.00000),
	cv::Point2f(2269.69287, 2776.41846)
};

const cv::Point2f targetControlMarkerPoint =	
	cv::Point2f(1254.50037, 2889.49976);
const int allowedDisplacementOfControlMarkerInWarpedImage = 25;

int main(int argc, const char * argv[])
{
	// Change this calibration to yours:
	//CameraCalibration calibration(526.58037684199849f, 524.65577209994706f, 318.41744018680112f, 202.96659047014398f);

	if (argc < 3)
	{
		std::cout << "MarkerAR: Input image and output image name not specified" << std::endl;
		//std::cout << "MarkerAR: Usage: marker_ar_demo <pattern image> [filepath to recorded video or image]" << std::endl;
		std::cout << "MarkerAR: Usage: MarkerAR_mytrial <inputImageName> <outputImageName>" << std::endl;
		return 1;
	}

	if (argc == 3)
	{
		std::string input = argv[1];
		std::string outputImageName = argv[2];
		cv::Mat testImage = cv::imread(input);
		if (!testImage.empty())
		{
			//processSingleImage(patternImage, calibration, testImage);
			//bool isPatternPresentInTestImg = processSingleImage(patternImage, testImage);

			bool isMarkersPresent[4] = { false, false, false, false };
			bool isControlMarkerPresentAndNotDisplaced = false;
			processSingleImage(testImage, refMarkersToTest, isMarkersPresent,
				isControlMarkerPresentAndNotDisplaced, outputImageName);

			// Important: TODO!!! Requires commenting
			// Different integer codes will be returned from the main function depending on
			// which of the 4 marker patterns
			// is missing from the image.
			// If all 4 corners are present, 0 will be returned.
			if (!isMarkersPresent[0])
			{
				return 3;
			}
			else if (!isMarkersPresent[1])
			{
				return 4;
			}
			else if (!isMarkersPresent[2])
			{
				return 5;
			}
			else if (!isMarkersPresent[3])
			{
				return 6;
			}
			else if (!isControlMarkerPresentAndNotDisplaced)
			{
				return 7;
			}
		}
		else
		{
			std::cout << "MarkerAR: Input image cannot be read" << std::endl;
			return 2;
		}
	}
	else
	{
		// TODO: change cerr to cout?
		std::cout << "MarkerAR: Invalid number of arguments passed" << std::endl;
		return 1;
	}

	//system("pause");

	return 0;
}


void processSingleImage(const cv::Mat& image, const int refMarkers[4][5][5],
	bool isMarkersPresent[4], bool& isControlMarkerPresentAndNotDisplaced,
	std::string outputImageName)
{
	MarkerDetector markerDetector(refMarkers);
	processFrame(image, markerDetector, isMarkersPresent,
		isControlMarkerPresentAndNotDisplaced, outputImageName);
}

bool processFrame(const cv::Mat& cameraFrame, MarkerDetector& markerDetector,
	bool isMarkersPresent[4], bool& isControlMarkerPresentAndNotDisplaced,
	std::string outputImageName)
{
	bool shouldQuit = false;
	isControlMarkerPresentAndNotDisplaced = false;

	// Clone image used for background (we will draw overlay on it)
	cv::Mat img = cameraFrame.clone();

	std::vector<cv::Point2f> markerCentres;
	markerDetector.processFrame(cameraFrame, isMarkersPresent, markerCentres);

	// if 4 all markers are present
	// warp the input image using a calculated perspective transform
	if (isMarkersPresent[0] && isMarkersPresent[1] &&
		isMarkersPresent[2] && isMarkersPresent[3])
	{
		// Find the perspective transformation that brings the A4 color sheet in input image to rectangular form
		// preknownMarkerPositions in order: top-left, top-right, bottom-left, bottom-right
		// https://stackoverflow.com/questions/8777603/what-is-the-simplest-way-to-convert-array-to-vector
		std::vector<cv::Point2f> preknownMarkerPositions(targetWarpedImgMarkerPoints,
			targetWarpedImgMarkerPoints + sizeof targetWarpedImgMarkerPoints / sizeof targetWarpedImgMarkerPoints[0]);
		cv::Mat markerTransform = cv::getPerspectiveTransform(markerCentres, preknownMarkerPositions);

		// Transform A4 color sheet in input image to get a rectangular image
		cv::Mat finalWarpedColorImg;
		cv::Size finalWarpedSize(targetWarpedImgWidth, targetWarpedImgHeight);
		//cv::warpPerspective(cameraFrame, finalWarpedColorImg, markerTransform, finalWarpedSize, cv::WARP_INVERSE_MAP | cv::INTER_CUBIC, cv::BORDER_TRANSPARENT);
		cv::warpPerspective(cameraFrame, finalWarpedColorImg, markerTransform, finalWarpedSize, cv::INTER_CUBIC, cv::BORDER_TRANSPARENT);

		// Check if the A4 color sheet is "curved"
		// by checking the coordinate of a control marker
		// in the finalWarpedColorImg
		std::vector<Marker> detectedControlMarkers;
		bool isControlMarkerPresent = markerDetector.processFrameToDetectOneMarker(
			finalWarpedColorImg, controlMarkerToTest, detectedControlMarkers);

		if (isControlMarkerPresent)
		{
			cv::Point2f markerCentre = detectedControlMarkers.front().getMarkerCentre();
			double markerCentreDisplacement = cv::norm(markerCentre - targetControlMarkerPoint);

			if (markerCentreDisplacement <= allowedDisplacementOfControlMarkerInWarpedImage)
			{
				isControlMarkerPresentAndNotDisplaced = true;

#if SHOW_DEBUG_IMAGES
				{
					cv::showAndSave(outputImageName, finalWarpedColorImg);
				}
#else
				{
					cv::save(outputImageName, finalWarpedColorImg);
				}
#endif
			}
		}

		// always save warped image when debugging
#if SHOW_DEBUG_IMAGES
		{
			cv::showAndSave(outputImageName, finalWarpedColorImg);
		}
#endif
	}

	return shouldQuit;
}